# Nginx语法

[Nginx HTTP核心模块指令和内置变量中文说明](https://my.oschina.net/jsan/blog/125861)

## location 规则匹配
### location 语法规则
```nginx
location [=|~|~*|^~] /uri/ {
        ····· 
}
```
> location 后接的匹配规则含义

>> `=`   开头表示精确匹配

>> `^~`  开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）

>> `~`   开头表示区分大小写的正则匹配

>> `~*`  开头表示不区分大小写的正则匹配

>> `!~`  区分大小写不匹配的正则

>> `!~*` 不区分大小写不匹配的正则

>> `/`   通用匹配，任何请求都会匹配到

>> `@`   定义一个内部命名的匹配（[等阶于`internal`](https://blog.sometimesnaive.org/article/72)），适用于`error_page`,`try_files`

### 当我们有多个 location 配置的情况下，其匹配顺序为：

> 首先匹配 "="，其次匹配 "^~", 其次是按文件中顺序的正则匹配，最后是交给 "/" 通用匹配。

> 当有匹配成功时候，停止匹配，按当前匹配规则处理请求。

### 比如现在同时存在如下所示匹配规则：
```
location = / {
   #规则A
}
location = /login {
   #规则B
}
location ^~ /static/ {
   #规则C
}
location ~ \.(gif|jpg|png|js|css)$ {
   #规则D
}
location ~* \.png$ {
   #规则E
}
location !~ \.xhtml$ {
   #规则F
}
location !~* \.xhtml$ {
   #规则G
}
location / {
   #规则H
}
```
#### 那么产生的效果如下
> 访问根目录/   比如 http://localhost/   将匹配规则A

> 访问 http://localhost/login   将匹配规则B，http://localhost/register 则匹配规则H

> 访问 http://localhost/static/a.html   将匹配规则C

> 访问 http://localhost/a.gif, http://localhost/b.jpg   将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 http://localhost/static/c.png 则优先匹配到规则C

> 访问 http://localhost/a.PNG   则匹配规则E，而不会匹配规则D，因为规则E不区分大小写

> 访问 http://localhost/a.xhtml   不会匹配规则F和规则G，http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到

> 访问 http://localhost/category/id/1111   则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在

### 在实际应用中，至少需要有三个匹配规则定义，如下：
```nginx
# 直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。
# 这里是直接转发给后端应用服务器了，也可以是一个静态首页
# 第一个必选规则
location = / {
    proxy_pass http://localhost:8080/index
}

# 第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项
# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用
location ^~ /static/ {
    root /webroot/static/;
}
location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ {
    root /webroot/res/;
}

# 第三个规则就是通用规则，用来转发动态请求到后端应用服务器
# 非静态文件请求就默认是动态请求，自己根据实际把握
# 毕竟目前的一些框架的流行，带 .php, .jsp 后缀的情况很少了
location / {
    proxy_pass http://localhost:8080/
}
```

### 内部调用

#### `internal`
> `internal` 指令用于指定只允许来自本地 `Nginx` 的内部调用，来自外部的访问会直接返回 `404 not found` 状态。

```nginx
# 定义一个内部调用location
location /internal/ {
    internal;
    proxy_pass http://192.168.1.110:8091;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;
    # 解决https->nginx->http->tomcat重定向问题
    proxy_redirect ~^http://([^:]+)(:\d+)?(.*)$ https://$1$3;
}
# 使用rewrite 内部重定向，其中 last 或 break 均可提供内部重定向。
location / {
    rewrite .* /internal/ last;
}
# 利用 Openresty 的 ngx.exec 模块
location / {
    access_by_lua_block {
        return ngx.exec("/internal/")
    }
}
```

#### `location @name`
> 命名location中不能再嵌套其它的命名location。

```nginx
# 匹配静态文件
location ~ .*\.(htm|html|js|css|jpg|png|gif|eot|svg|ttf|woff|woff2)$ {
    # 如果文件不存在
    #if (!-f $request_filename) {
        #content_by_lua_block {
                #ngx.exec("@pass");
        #}
    #}
    root /www/wwwroot/api;
    # 按顺序检查文件是否存在，返回第一个找到的文件。结尾的斜线表示为文件夹 -$uri/。
    # 如果所有的文件都找不到，会进行一个内部重定向到最后一个参数
    try_files $uri $uri/ @pass;
}
# 通用匹配
location / {
    # 或者使用`ngx.exec`主要实现的是内部的重定向
    # `ngx.redirect`是外部重定向
    content_by_lua_block {
        ngx.exec("@pass");
    }
}
location @pass {
    proxy_pass http://192.168.1.110:8091;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;
    # 解决https->nginx->http->tomcat重定向问题
    proxy_redirect ~^http://([^:]+)(:\d+)?(.*)$  https://$1$3;
}
```
## rewrite 语法
> `last`       – 基本上都用这个 Flag

> `break`      – 中止 Rewirte，不在继续匹配

> `redirect`   – 返回临时重定向的HTTP状态302

> `permanent`  – 返回永久重定向的HTTP状态301
### 可以用来判断的表达式
> `-f` 和 `!-f`    用来判断是否存在文件

> `-d` 和 `!-d`    用来判断是否存在目录

> `-e` 和 `!-e`    用来判断是否存在文件或目录

> `-x` 和 `!-x`    用来判断文件是否可执行
### 可以用作判断的全局变量
> 例：http://localhost:88/test1/test2/test.php
  
>> $host：localhost

>> $server_port：88

>> $request_uri：http://localhost:88/test1/test2/test.php

>> $document_uri：/test1/test2/test.php

>> $document_root：D:\nginx/html

>> $request_filename：D:\nginx/html/test1/test2/test.php
## Redirect语法
```nginx
server {
    listen 80;
    server_name start.igrow.cn;
    index index.html index.php;
    root html;
    if ($http_host !~ “^star\.igrow\.cn$&quot {
        rewrite ^(.*) http://star.igrow.cn$1 redirect;
    }
}
```
## 防盗链
```
location ~* \.(gif|jpg|swf)$ {
    valid_referers none blocked start.igrow.cn sta.igrow.cn;
    if ($invalid_referer) {
        rewrite ^/ http://$host/logo.png;
    }
}
```
## 根据文件类型设置过期时间
```nginx
location ~* \.(js|css|jpg|jpeg|gif|png|swf)$ {
    if (-f $request_filename) {
        expires 1h;
        break;
    }
}
```
## 禁止访问某个目录
```nginx
location ~* \.(txt|doc)${
    root /data/www/wwwroot/linuxtone/test;
    deny all;
}
```
## 可用的全局变量
> `$args` 这个变量等于请求行中(GET请求)的参数，同`$query_string`
> 
> `$is_args` 如果已经设置$args，则该变量的值为"？"，否则为""。
>
> `$content_length` 请求头中的Content-length字段。
> 
> `$content_type` 请求头中的Content-Type字段。
> 
> `$document_root` 当前请求在root指令中指定的值。
> 
> `$document_uri` 与`$uri`相同。
> 
> `$host` 请求主机头字段，否则为服务器名称。
> 
> `$http_user_agent` 客户端agent信息
> 
> `$http_cookie` 客户端cookie信息
> 
> `$limit_rate` 这个变量可以限制连接速率。
> 
> `$request_body_file` 客户端请求主体信息的临时文件名。
> 
> `$request_method` 客户端请求的动作，通常为GET或POST。
> 
> `$remote_addr` 客户端的IP地址。
> 
> `$remote_port` 客户端的端口。
> 
> `$remote_user` 已经经过Auth Basic Module验证的用户名。
> 
> `$request_filename` 当前请求的文件路径，由root或alias指令与URI请求生成。
> 
> `$request_uri`  包含请求参数的原始URI，不包含主机名，如："/?dir=DeveloperTool"。
> 
> `$query_string` 这个变量等于请求行中的参数，同`$args`
> 
> `$scheme` HTTP协议（如http，https）。
> 
> `$server_protocol` 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。
> 
> `$server_addr` 服务器地址，在完成一次系统调用后可以确定这个值。
> 
> `$server_name` 服务器名称。
> 
> `$server_port` 请求到达服务器的端口号。
> 
> `$uri` 不带请求参数的当前URI， uri不包含主机名

## 判断`user_agent`
```nginx

if ( $http_user_agent ~ "(MIDP)|(WAP)|(UP.Browser)|(Smartphone)|(Obigo)|(Mobile)|(AU.Browser)|(wxd.Mms)|(WxdB.Browser)|(CLDC)|(UP.Link)|(KM.Browser)|(UCWEB)|(SEMC-Browser)|(Mini)|(Symbian)|(Palm)|(Nokia)|(Panasonic)|(MOT-)|(SonyEricsson)|(NEC-)|(Alcatel)|(Ericsson)|(BENQ)|(BenQ)|(Amoisonic)|(Amoi-)|(Capitel)|(PHILIPS)|(SAMSUNG)|(Lenovo)|(Mitsu)|(Motorola)|(SHARP)|(WAPPER)|(LG-)|(LG/)|(EG900)|(CECT)|(Compal)|(kejian)|(Bird)|(BIRD)|(G900/V1.0)|(Arima)|(CTL)|(TDG)|(Daxian)|(DAXIAN)|(DBTEL)|(Eastcom)|(EASTCOM)|(PANTECH)|(Dopod)|(Haier)|(HAIER)|(KONKA)|(KEJIAN)|(LENOVO)|(Soutec)|(SOUTEC)|(SAGEM)|(SEC-)|(SED-)|(EMOL-)|(INNO55)|(ZTE)|(iPhone)|(Android)|(Windows CE)|(Wget)|(Java)|(curl)|(Opera)" ) {
    proxy_pass https://m.apkpure.com/cn;
    #proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;
}
```

## `proxy_pass`指令
> nginx无法在proxy_pass指令中处理所需的URI部分，因为位于指定的位置（因此是错误消息）。
> 这是因为nginx是以模块化的方式构建的，每个配置块都是由各个模块在各个阶段读取的。
> 所以请记住，proxy_pass在以下情况下，指令中不能有URI ：
>> 正则表达式位置
>>
>> 命名的地点
>>
>> if 块